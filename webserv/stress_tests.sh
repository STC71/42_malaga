#!/bin/bash

##############################################################################
# stress_tests.sh - Pruebas avanzadas para "romper" webserv
# 
# üéØ PROP√ìSITO EDUCATIVO:
# Estas pruebas intentan encontrar vulnerabilidades, memory leaks,
# crashes y comportamientos inesperados en tu servidor web.
# 
# üî¨ QU√â APRENDER√ÅS:
# - C√≥mo funciona realmente select() bajo presi√≥n extrema
# - T√©cnicas de ataque reales contra servidores HTTP
# - Gesti√≥n correcta de memoria y procesos en C++
# - Manejo robusto de errores y casos extremos
# - Diferencia entre servidor "funciona" vs "es seguro"
#
# ‚ö†Ô∏è  ADVERTENCIA:
# Estos tests son MUY intensivos y pueden exponer bugs serios.
# Solo ejecutar en entorno de desarrollo, NUNCA en producci√≥n.
##############################################################################

RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Funci√≥n para configurar posiciones de ventana din√°micamente
setup_window_positions() {
    # Detectar tama√±o de pantalla para posicionamiento √≥ptimo
    if command -v xdpyinfo >/dev/null 2>&1; then
        SCREEN_WIDTH=$(xdpyinfo 2>/dev/null | grep dimensions | awk '{print $2}' | cut -d'x' -f1 || echo "1920")
        SCREEN_HEIGHT=$(xdpyinfo 2>/dev/null | grep dimensions | awk '{print $2}' | cut -d'x' -f2 || echo "1080")
        echo -e "${BLUE}üì∫ Pantalla detectada: ${SCREEN_WIDTH}x${SCREEN_HEIGHT}${NC}"
    else
        SCREEN_WIDTH=1920
        SCREEN_HEIGHT=1080
        echo -e "${YELLOW}‚ö†Ô∏è  xdpyinfo no disponible, usando resoluci√≥n est√°ndar: ${SCREEN_WIDTH}x${SCREEN_HEIGHT}${NC}"
    fi
    
    # Calcular posiciones para m√°xima separaci√≥n
    # Terminal servidor: mitad derecha de la pantalla
    SERVER_WIDTH=80
    SERVER_HEIGHT=30
    SERVER_X=$((SCREEN_WIDTH / 2 + 50))  # Mitad derecha + margen
    SERVER_Y=50
    
    # Terminal stress tests: mitad izquierda de la pantalla  
    STRESS_WIDTH=80
    STRESS_HEIGHT=30
    STRESS_X=50  # Margen izquierdo
    STRESS_Y=50
    
    # Exportar para uso global
    export SERVER_WIDTH SERVER_HEIGHT SERVER_X SERVER_Y
    export STRESS_WIDTH STRESS_HEIGHT STRESS_X STRESS_Y
    export SCREEN_WIDTH SCREEN_HEIGHT
    
    echo -e "${BLUE}üéØ Posiciones calculadas:${NC}"
    echo -e "${BLUE}   üñ•Ô∏è  Servidor: (${SERVER_X}, ${SERVER_Y}) - lado derecho${NC}"
    echo -e "${BLUE}   ‚ö° Stress tests: (${STRESS_X}, ${STRESS_Y}) - lado izquierdo${NC}"
}

echo -e "${RED}üî• STRESS TESTS - INTENTANDO ROMPER EL SERVIDOR üî•${NC}"
echo -e "${BLUE}üìÖ DURACI√ìN ESTIMADA TOTAL: ~25-30 minutos${NC}"
echo -e "${BLUE}üéØ 16 categor√≠as de ataques destructivos${NC}"
echo -e "${YELLOW}‚ö†Ô∏è  ADVERTENCIA: Estos tests son intensivos y tardan tiempo real${NC}"
echo -e "${YELLOW}‚òï Prep√°rate un caf√© - esto va para largo...${NC}"
echo ""

# Configurar posiciones de ventana din√°micamente
setup_window_positions

# Funci√≥n para detectar el emulador de terminal disponible
detect_terminal() {
    if command -v gnome-terminal >/dev/null 2>&1; then
        echo "gnome-terminal"
    elif command -v xterm >/dev/null 2>&1; then
        echo "xterm"
    elif command -v konsole >/dev/null 2>&1; then
        echo "konsole"
    elif command -v terminator >/dev/null 2>&1; then
        echo "terminator"
    elif command -v mate-terminal >/dev/null 2>&1; then
        echo "mate-terminal"
    elif command -v xfce4-terminal >/dev/null 2>&1; then
        echo "xfce4-terminal"
    else
        echo "none"
    fi
}

# Funci√≥n para posicionar la terminal actual de stress tests
position_stress_terminal() {
    if [ -n "$DISPLAY" ] && command -v xdotool >/dev/null 2>&1; then
        echo -e "${BLUE}üéØ Posicionando terminal de stress tests en lado izquierdo...${NC}"
        
        # Intentar encontrar la ventana de la terminal actual
        CURRENT_PID=$$
        CURRENT_WINDOW=$(xdotool search --pid $CURRENT_PID 2>/dev/null | head -1)
        
        if [ -z "$CURRENT_WINDOW" ]; then
            # Si no encontramos por PID, intentar por nombre de ventana
            CURRENT_WINDOW=$(xdotool getactivewindow 2>/dev/null)
        fi
        
        if [ -n "$CURRENT_WINDOW" ] && [ -n "$STRESS_X" ] && [ -n "$STRESS_Y" ]; then
            # Posicionar la ventana en el lado izquierdo
            xdotool windowmove "$CURRENT_WINDOW" "$STRESS_X" "$STRESS_Y" 2>/dev/null || true
            # Opcional: redimensionar la ventana (usar ancho calculado din√°micamente)
            TERMINAL_WIDTH=$((SCREEN_WIDTH / 2 - 100))  # Mitad de pantalla menos margen
            TERMINAL_HEIGHT=$((SCREEN_HEIGHT - 150))    # Altura de pantalla menos margen
            xdotool windowsize "$CURRENT_WINDOW" "$TERMINAL_WIDTH" "$TERMINAL_HEIGHT" 2>/dev/null || true
            # Asegurar que est√© en primer plano
            xdotool windowactivate "$CURRENT_WINDOW" 2>/dev/null || true
            echo -e "${GREEN}‚úÖ Terminal de stress tests posicionada en (${STRESS_X},${STRESS_Y})${NC}"
            return 0
        else
            echo -e "${YELLOW}‚ö†Ô∏è  No se pudo posicionar autom√°ticamente la terminal de stress tests${NC}"
            return 1
        fi
    else
        echo -e "${YELLOW}‚ö†Ô∏è  xdotool no disponible - no se puede posicionar terminal autom√°ticamente${NC}"
        return 1
    fi
}

# Verificar si webserv est√° corriendo, y si no, intentar iniciarlo autom√°ticamente
if ! pgrep webserv > /dev/null; then
    echo -e "${YELLOW}‚ö° webserv no est√° corriendo. Iniciando autom√°ticamente...${NC}"
    
    # Verificar que el binario webserv existe
    if [ ! -f "./webserv" ]; then
        echo -e "${RED}‚ùå Binario './webserv' no encontrado. Compilando primero...${NC}"
        if [ -f "Makefile" ]; then
            echo -e "${BLUE}üî® Ejecutando 'make'...${NC}"
            make
            if [ $? -ne 0 ]; then
                echo -e "${RED}‚ùå Error al compilar webserv${NC}"
                exit 1
            fi
        else
            echo -e "${RED}‚ùå No se encontr√≥ Makefile. Compila webserv manualmente.${NC}"
            exit 1
        fi
    fi
    
    # Detectar terminal disponible
    TERMINAL=$(detect_terminal)
    
    if [ "$TERMINAL" = "none" ]; then
        echo -e "${RED}‚ùå No se encontr√≥ un emulador de terminal compatible.${NC}"
        echo -e "${BLUE}üí° Inicia webserv manualmente en otra terminal: ./webserv config/default.conf${NC}"
        exit 1
    fi
    
    echo -e "${BLUE}üñ•Ô∏è  Configurando terminales para m√°xima separaci√≥n:${NC}"
    echo -e "${BLUE}   üì∫ Pantalla detectada: ${SCREEN_WIDTH}x${SCREEN_HEIGHT}${NC}"
    echo -e "${BLUE}   üñ•Ô∏è  Terminal servidor: mitad derecha (${SERVER_X}+${SERVER_Y})${NC}"
    echo -e "${BLUE}   ‚ö° Terminal stress: mitad izquierda (${STRESS_X}+${STRESS_Y})${NC}"
    
    # Calcular geometr√≠as para ambas terminales
    SERVER_GEOMETRY="${SERVER_WIDTH}x${SERVER_HEIGHT}+${SERVER_X}+${SERVER_Y}"
    STRESS_GEOMETRY="${STRESS_WIDTH}x${STRESS_HEIGHT}+${STRESS_X}+${STRESS_Y}"
    
    # Lanzar webserv en nueva terminal seg√∫n el tipo detectado
    case "$TERMINAL" in
        "gnome-terminal")
            gnome-terminal --title="WebServ Server" --geometry="$SERVER_GEOMETRY" -- bash -c "echo -e '\033[0;32müöÄ INICIANDO WEBSERV SERVER\033[0m'; echo -e '\033[0;34müìÇ Configuraci√≥n: config/default.conf\033[0m'; echo -e '\033[0;33m‚ö° Puerto: 9000\033[0m'; echo ''; ./webserv config/default.conf; echo ''; echo -e '\033[0;31müíÄ SERVIDOR TERMINADO\033[0m'; read -p 'Presiona Enter para cerrar...'" &
            ;;
        "xterm")
            xterm -title "WebServ Server" -geometry "$SERVER_GEOMETRY" -e bash -c "echo -e '\033[0;32müöÄ INICIANDO WEBSERV SERVER\033[0m'; echo -e '\033[0;34müìÇ Configuraci√≥n: config/default.conf\033[0m'; echo -e '\033[0;33m‚ö° Puerto: 9000\033[0m'; echo ''; ./webserv config/default.conf; echo ''; echo -e '\033[0;31müíÄ SERVIDOR TERMINADO\033[0m'; read -p 'Presiona Enter para cerrar...'" &
            ;;
        "konsole")
            konsole --title "WebServ Server" --geometry "$SERVER_GEOMETRY" -e bash -c "echo -e '\033[0;32müöÄ INICIANDO WEBSERV SERVER\033[0m'; echo -e '\033[0;34müìÇ Configuraci√≥n: config/default.conf\033[0m'; echo -e '\033[0;33m‚ö° Puerto: 9000\033[0m'; echo ''; ./webserv config/default.conf; echo ''; echo -e '\033[0;31müíÄ SERVIDOR TERMINADO\033[0m'; read -p 'Presiona Enter para cerrar...'" &
            ;;
        "terminator")
            terminator --title="WebServ Server" --geometry="$SERVER_GEOMETRY" -e "bash -c \"echo -e '\033[0;32müöÄ INICIANDO WEBSERV SERVER\033[0m'; echo -e '\033[0;34müìÇ Configuraci√≥n: config/default.conf\033[0m'; echo -e '\033[0;33m‚ö° Puerto: 9000\033[0m'; echo ''; ./webserv config/default.conf; echo ''; echo -e '\033[0;31müíÄ SERVIDOR TERMINADO\033[0m'; read -p 'Presiona Enter para cerrar...'\"" &
            ;;
        "mate-terminal")
            mate-terminal --title="WebServ Server" --geometry="$SERVER_GEOMETRY" -e "bash -c \"echo -e '\033[0;32müöÄ INICIANDO WEBSERV SERVER\033[0m'; echo -e '\033[0;34müìÇ Configuraci√≥n: config/default.conf\033[0m'; echo -e '\033[0;33m‚ö° Puerto: 9000\033[0m'; echo ''; ./webserv config/default.conf; echo ''; echo -e '\033[0;31müíÄ SERVIDOR TERMINADO\033[0m'; read -p 'Presiona Enter para cerrar...'\"" &
            ;;
        "xfce4-terminal")
            xfce4-terminal --title="WebServ Server" --geometry="$SERVER_GEOMETRY" -e "bash -c \"echo -e '\033[0;32müöÄ INICIANDO WEBSERV SERVER\033[0m'; echo -e '\033[0;34müìÇ Configuraci√≥n: config/default.conf\033[0m'; echo -e '\033[0;33m‚ö° Puerto: 9000\033[0m'; echo ''; ./webserv config/default.conf; echo ''; echo -e '\033[0;31müíÄ SERVIDOR TERMINADO\033[0m'; read -p 'Presiona Enter para cerrar...'\"" &
            ;;
    esac
    
    echo -e "${BLUE}‚è≥ Esperando 3 segundos para que webserv se inicie...${NC}"
    sleep 3
    
    # Asegurar que la terminal actual (stress tests) est√© en primer plano
    # Esto funciona en la mayor√≠a de entornos de escritorio
    if command -v wmctrl >/dev/null 2>&1; then
        # Usar wmctrl si est√° disponible para gesti√≥n avanzada de ventanas
        CURRENT_WINDOW=$(xdotool getactivewindow 2>/dev/null || echo "")
        if [ -n "$CURRENT_WINDOW" ]; then
            wmctrl -i -a "$CURRENT_WINDOW" 2>/dev/null || true
        fi
    else
        # Fallback: simplemente enviar foco a la terminal actual
        if [ -n "$DISPLAY" ]; then
            # Intentar traer foco a la terminal actual usando xdotool si est√° disponible
            if command -v xdotool >/dev/null 2>&1; then
                CURRENT_PID=$$
                CURRENT_WINDOW=$(xdotool search --pid $CURRENT_PID 2>/dev/null | head -1)
                if [ -n "$CURRENT_WINDOW" ]; then
                    xdotool windowactivate "$CURRENT_WINDOW" 2>/dev/null || true
                fi
            fi
        fi
    fi
    
    # Verificar que webserv se haya iniciado correctamente
    if ! pgrep webserv > /dev/null; then
        echo -e "${RED}‚ùå Error: webserv no se pudo iniciar autom√°ticamente${NC}"
        echo -e "${BLUE}üí° Inicia webserv manualmente en la terminal abierta: ./webserv config/default.conf${NC}"
        exit 1
    fi
    
    echo -e "${GREEN}‚úÖ webserv iniciado correctamente en nueva terminal${NC}"
else
    echo -e "${GREEN}‚úÖ webserv ya est√° corriendo${NC}"
    # Incluso si webserv ya est√° corriendo, intentar posicionar la terminal de stress tests
    echo -e "${BLUE}üí° Configurando posici√≥n de terminal para mejor ergonom√≠a...${NC}"
fi

WEBSERV_PID=$(pgrep webserv)
echo -e "${BLUE}üìç PID del servidor: $WEBSERV_PID${NC}"

# Posicionar la terminal actual de stress tests en la mitad izquierda
position_stress_terminal

echo -e "${BLUE}üéÆ Configuraci√≥n de terminales completada:${NC}"
echo -e "${BLUE}   üñ•Ô∏è  Terminal servidor: lado derecho${NC}"
echo -e "${BLUE}   ‚ö° Terminal stress tests: lado izquierdo (terminal actual)${NC}"
echo ""

# =============================================================================
# TEST 1: MALFORMED HTTP REQUESTS
# =============================================================================
# OBJETIVO: Verificar que el parser HTTP maneja correctamente requests malformados
# SIN crashes, memory corruption o comportamiento indefinido
# Importante para: select() debe seguir funcionando aunque reciba datos basura

echo -e "\n${YELLOW}üß™ TEST 1: Requests HTTP malformados${NC} ${BLUE}[1/16]${NC}"
echo -e "${BLUE}‚è±Ô∏è  Tiempo estimado: ~30-45 segundos${NC}"
echo -e "${BLUE}üéØ PROP√ìSITO: Verificar robustez del parser HTTP ante datos corruptos${NC}"
echo -e "${BLUE}   Un servidor web debe manejar requests inv√°lidos sin crashear.${NC}"
echo -e "${BLUE}   Errores comunes: buffer overflow, segfaults por datos inesperados.${NC}"

echo -e "   ${YELLOW}‚Üí${NC} Request completamente vac√≠o..."
echo -e "     ${BLUE}¬øQu√© pasa?: Enviamos solo CRLF sin m√©todo HTTP v√°lido${NC}"
echo -e "     ${BLUE}¬øPor qu√©?: Simula conexi√≥n corrupta o cliente malicioso${NC}"
echo -e "     ${BLUE}Esperado: Respuesta 400 Bad Request, servidor sigue vivo${NC}"
# PRUEBA: Enviar solo CRLF sin ning√∫n contenido HTTP v√°lido
# OBJETIVO: Verificar que recv() no explota con datos vac√≠os
echo -e "\r\n\r\n" | nc -w 2 localhost 9000 >/dev/null 2>&1 &
sleep 1

echo -e "   ${YELLOW}‚Üí${NC} Bombardeo con 1000 headers HTTP..."
echo -e "     ${BLUE}¬øQu√© pasa?: Enviamos request con mil headers diferentes${NC}"
echo -e "     ${BLUE}¬øPor qu√©?: Probar l√≠mites de memoria y DoS por headers${NC}"
echo -e "     ${BLUE}Esperado: L√≠mite razonable o respuesta 413 Entity Too Large${NC}"
# PRUEBA: Bombardear con 1000 headers para intentar overflow de memoria
# OBJETIVO: Verificar l√≠mites de parsing y que no hay buffer overflow
(for i in {1..1000}; do echo "Header$i: value$i"; done; echo -e "\r\n") | nc -w 2 localhost 9000 >/dev/null 2>&1 &
sleep 1

echo -e "   ${YELLOW}‚Üí${NC} Content-Length mentiroso..."
echo -e "     ${BLUE}¬øQu√© pasa?: Decimos que enviamos 999999 bytes pero solo 4${NC}"
echo -e "     ${BLUE}¬øPor qu√©?: Probar que el servidor no se bloquea esperando datos${NC}"
echo -e "     ${BLUE}Esperado: Timeout correcto o error 400, sin bloqueo infinito${NC}"
# PRUEBA: Content-Length dice 999999 pero solo env√≠a "DATA" (4 bytes)
# OBJETIVO: Verificar que recv() maneja discrepancias sin bloquear select()
echo -e "POST /Uploads/ HTTP/1.1\r\nHost: localhost\r\nContent-Length: 999999\r\n\r\nDATA" | nc -w 2 localhost 9000 >/dev/null 2>&1 &
sleep 1

# Verificar que el servidor sigue vivo
if kill -0 $WEBSERV_PID 2>/dev/null; then
    echo -e "   ${GREEN}‚úÖ Servidor sobrevivi√≥ requests malformados${NC}"
else
    echo -e "   ${RED}üíÄ SERVIDOR MURI√ì - TEST 1 FAILED${NC}"
    exit 1
fi

# =============================================================================
# TEST 2: CONEXIONES MASIVAS
# =============================================================================
# OBJETIVO: Probar l√≠mites de file descriptors y escalabilidad de select()
# select() tiene l√≠mite FD_SETSIZE (t√≠picamente 1024), verificar manejo correcto
# Importante para: Que el servidor no crashee al alcanzar l√≠mites del sistema

echo -e "\n${YELLOW}üß™ TEST 2: Conexiones masivas simult√°neas${NC} ${BLUE}[2/16]${NC}"
echo -e "${BLUE}‚è±Ô∏è  Tiempo estimado: ~2-3 minutos (500 conexiones + an√°lisis FDs)${NC}"
echo -e "${BLUE}üéØ PROP√ìSITO: Probar escalabilidad y l√≠mites de file descriptors${NC}"
echo -e "${BLUE}   select() tiene l√≠mite FD_SETSIZE (normalmente 1024 conexiones).${NC}"
echo -e "${BLUE}   Un servidor real debe manejar cientos de conexiones simult√°neas.${NC}"

echo -e "   ${YELLOW}‚Üí${NC} Creando 500 conexiones TCP simult√°neas..."
echo -e "     ${BLUE}¬øQu√© pasa?: Abrimos 500 sockets TCP concurrentes al servidor${NC}"
echo -e "     ${BLUE}¬øPor qu√©?: Probar l√≠mites de select() y gesti√≥n de FDs${NC}"
echo -e "     ${BLUE}Esperado: Servidor acepta conexiones hasta l√≠mite del SO${NC}"
# PRUEBA: Crear 500 conexiones TCP concurrentes para saturar FD table
# OBJETIVO: Verificar que select() maneja correctamente muchos FDs
# Y que accept() no falla cuando hay muchas conexiones pendientes
for i in {1..500}; do
    nc -w 1 localhost 9000 >/dev/null 2>&1 &
    if [ $((i % 100)) -eq 0 ]; then
        echo -e "     ${GREEN}‚úì${NC} $i conexiones establecidas..."
    fi
done

sleep 3

echo -e "   ${YELLOW}‚Üí${NC} Analizando uso de file descriptors..."
# Verificar descriptores de archivo
# DIAGN√ìSTICO: Contar FDs abiertos para detectar leaks
FD_COUNT=$(lsof -p $WEBSERV_PID 2>/dev/null | wc -l)
echo -e "     ${BLUE}File descriptors activos: $FD_COUNT${NC}"
echo -e "     ${BLUE}¬øEs normal?: Cada conexi√≥n TCP = 1 FD + sockets de escucha${NC}"
echo -e "     ${BLUE}¬øCu√°ndo preocuparse?: Si FD_COUNT > conexiones reales${NC}"

if kill -0 $WEBSERV_PID 2>/dev/null; then
    echo -e "   ${GREEN}‚úÖ Servidor resiste sobrecarga de conexiones${NC}"
else
    echo -e "   ${RED}üíÄ SERVIDOR MURI√ì - Posible overflow de FDs${NC}"
    exit 1
fi

# =============================================================================
# TEST 3: BINARY DATA Y CARACTERES ESPECIALES
# =============================================================================
# OBJETIVO: Verificar que recv() y send() manejan datos binarios sin corruption
# Los datos binarios pueden contener \0 que truncan strings C incorrectamente
# Importante para: Que el parsing HTTP no se confunda con caracteres especiales

echo -e "\n${YELLOW}üß™ TEST 3: Datos binarios y caracteres especiales${NC} ${BLUE}[3/16]${NC}"
echo -e "${BLUE}‚è±Ô∏è  Tiempo estimado: ~1-2 minutos${NC}"
echo -e "${BLUE}üéØ PROP√ìSITO: Verificar manejo seguro de datos binarios${NC}"
echo -e "${BLUE}   Datos binarios contienen bytes especiales (\\0, \\xFF, etc.)${NC}"
echo -e "${BLUE}   Strings en C se truncan con \\0 - el servidor debe usar length.${NC}"

echo -e "   ${YELLOW}‚Üí${NC} Enviando 1KB de datos binarios aleatorios..."
echo -e "     ${BLUE}¬øQu√© pasa?: Generamos bytes totalmente aleatorios con /dev/urandom${NC}"
echo -e "     ${BLUE}¬øPor qu√©?: Probar que recv() no se confunde con \\0 o bytes raros${NC}"
echo -e "     ${BLUE}Esperado: POST procesado correctamente, sin truncamiento${NC}"
# PRUEBA: Enviar 1KB de datos completamente aleatorios (incluyendo \0, \xFF)
# OBJETIVO: Verificar que el servidor no hace assumptions sobre contenido texto
dd if=/dev/urandom bs=1K count=1 2>/dev/null | curl -s -X POST --data-binary @- http://localhost:9000/Uploads/binary.dat >/dev/null 2>&1

echo "   - URLs con caracteres especiales..."
# PRUEBA: URLs con null bytes, caracteres no-ASCII y path traversal encoding
# OBJETIVO: Verificar sanitizaci√≥n de URLs y que no hay buffer overruns
curl -s "http://localhost:9000/test%00%FF%FE" >/dev/null 2>&1
curl -s "http://localhost:9000/../../etc/passwd" >/dev/null 2>&1
curl -s "http://localhost:9000/%2e%2e%2f%2e%2e%2fetc%2fpasswd" >/dev/null 2>&1

if kill -0 $WEBSERV_PID 2>/dev/null; then
    echo -e "   ${GREEN}‚úÖ Servidor maneja datos especiales${NC}"
else
    echo -e "   ${RED}üíÄ SERVIDOR MURI√ì - TEST 3 FAILED${NC}"
    exit 1
fi

# =============================================================================
# TEST 4: CGI STRESS
# =============================================================================
# OBJETIVO: Verificar manejo correcto de procesos fork() masivos sin leaks
# Los CGI crean procesos hijo que deben ser recogidos con waitpid()
# Importante para: Que no se acumulen zombies y que select() no se bloquee

echo -e "\n${YELLOW}üß™ TEST 4: Stress test CGI${NC} ${BLUE}[4/16]${NC}"
echo -e "${BLUE}‚è±Ô∏è  Tiempo estimado: ~2-4 minutos (40 procesos CGI + an√°lisis)${NC}"
echo -e "${BLUE}üéØ PROP√ìSITO: Probar manejo masivo de procesos fork() sin memory leaks${NC}"
echo -e "${BLUE}   Cada request CGI = fork() + execve() + waitpid()${NC}"
echo -e "${BLUE}   Es normal ver zombies temporales durante alta concurrencia.${NC}"
echo -e "${BLUE}   Problema grave: zombies que NO desaparecen tras el test.${NC}"

echo -e "   ${YELLOW}‚Üí${NC} Lanzando 40 procesos CGI en grupos escalonados..."
echo -e "     ${BLUE}¬øQu√© pasa?: Ejecutamos Python y PHP scripts simult√°neamente${NC}"
echo -e "     ${BLUE}¬øPor qu√©?: Probar que fork()/execve()/waitpid() escala bien${NC}"
echo -e "     ${BLUE}Esperado: Todos los CGI responden, zombies se limpian solos${NC}"

# PRUEBA: Lanzar 40 procesos CGI concurrentes (20 Python + 20 PHP)
# OBJETIVO: Verificar que fork()/waitpid() funciona bajo alta concurrencia
# Y que los procesos padre no se bloquean esperando a los hijos

echo -e "     ${BLUE}üí° Lanzando en grupos espaciados para reducir pressure de zombies${NC}"
# Lanzar en grupos m√°s peque√±os para reducir pressure de zombies
echo -e "     ${YELLOW}‚Üí${NC} Grupo 1: 10 procesos CGI (Python + PHP)..."
for i in {1..5}; do
    curl -s http://localhost:9000/cgi-bin/script.py >/dev/null 2>&1 &
    curl -s http://localhost:9000/cgi-bin/simple.php >/dev/null 2>&1 &
done
sleep 2

echo -e "     ${YELLOW}‚Üí${NC} Grupo 2: 10 procesos CGI m√°s..."
for i in {6..10}; do
    curl -s http://localhost:9000/cgi-bin/script.py >/dev/null 2>&1 &
    curl -s http://localhost:9000/cgi-bin/simple.php >/dev/null 2>&1 &
done
sleep 2

echo -e "     ${YELLOW}‚Üí${NC} Grupo 3: 10 procesos CGI m√°s..."
for i in {11..15}; do
    curl -s http://localhost:9000/cgi-bin/script.py >/dev/null 2>&1 &
    curl -s http://localhost:9000/cgi-bin/simple.php >/dev/null 2>&1 &
done
sleep 2

echo "     ‚Üí Grupo 4: 10 procesos CGI..."
for i in {16..20}; do
    curl -s http://localhost:9000/cgi-bin/script.py >/dev/null 2>&1 &
    curl -s http://localhost:9000/cgi-bin/simple.php >/dev/null 2>&1 &
done

echo "   - Esperando finalizaci√≥n de todos los CGI..."
sleep 5

# Verificar procesos CGI hu√©rfanos
# DIAGN√ìSTICO: Detectar procesos CGI que no fueron recogidos por waitpid()
CGI_PROCESSES=$(pgrep -f "php-cgi\|python3.*script" | wc -l)
echo "   - Procesos CGI activos: $CGI_PROCESSES"
echo -e "   ${BLUE}üí° Los procesos CGI activos son aquellos que a√∫n se est√°n ejecutando${NC}"
echo -e "   ${BLUE}   ‚Üí Si hay muchos, pueden ser scripts que no terminaron correctamente${NC}"
echo -e "   ${BLUE}   ‚Üí Si hay pocos/cero, indica excelente gesti√≥n de procesos${NC}"

if kill -0 $WEBSERV_PID 2>/dev/null; then
    echo -e "   ${GREEN}‚úÖ Servidor maneja CGI stress perfectamente${NC}"
    echo -e "   ${GREEN}üí° Fork/waitpid funcionando correctamente bajo alta concurrencia${NC}"
else
    echo -e "   ${RED}üíÄ SERVIDOR MURI√ì - TEST 4 FAILED${NC}"
    exit 1
fi

# =============================================================================
# TEST 5: MEMORY STRESS
# =============================================================================
# OBJETIVO: Detectar memory leaks y verificar manejo de requests grandes
# Requests de 1MB pueden revelar problemas de buffer allocation/deallocation
# Importante para: Que la memoria se libere correctamente tras cada request

echo -e "\n${YELLOW}üß™ TEST 5: Memory stress test${NC} ${BLUE}[5/16]${NC}"
echo -e "${BLUE}‚è±Ô∏è  Tiempo estimado: ~1-2 minutos (10MB upload + an√°lisis memoria)${NC}"
echo -e "${BLUE}üéØ PROP√ìSITO: Detectar memory leaks con requests de gran tama√±o${NC}"
echo -e "${BLUE}   Requests de 1MB+ pueden revelar problemas de malloc/free.${NC}"
echo -e "${BLUE}   El servidor debe allocar, procesar y liberar memoria correctamente.${NC}"

echo -e "   ${YELLOW}‚Üí${NC} Enviando 10 uploads concurrentes de 1MB cada uno..."
echo -e "     ${BLUE}¬øQu√© pasa?: Generamos 10MB total de datos con /dev/zero${NC}"
echo -e "     ${BLUE}¬øPor qu√©?: Probar allocation de buffers grandes y liberaci√≥n${NC}"
echo -e "     ${BLUE}Esperado: Memoria se libera tras cada upload, sin leaks${NC}"
# PRUEBA: 10 uploads concurrentes de 1MB cada uno para estresar memoria
# OBJETIVO: Verificar que no hay memory leaks en el manejo de datos grandes
# Y que recv() puede manejar m√∫ltiples buffers grandes simult√°neamente
for i in {1..10}; do
    dd if=/dev/zero bs=1M count=1 2>/dev/null | curl -s -X POST --data-binary @- http://localhost:9000/Uploads/big$i.dat >/dev/null 2>&1 &
    if [ $((i % 3)) -eq 0 ]; then
        echo -e "     ${GREEN}‚úì${NC} $i uploads de 1MB iniciados..."
    fi
done

sleep 3

echo -e "   ${YELLOW}‚Üí${NC} Analizando uso de memoria del servidor..."
# Verificar uso de memoria
# DIAGN√ìSTICO: Medir VSZ (Virtual Size) para detectar memory leaks
MEMORY_KB=$(ps -o pid,vsz --no-headers -p $WEBSERV_PID | awk '{print $2}')
MEMORY_MB=$((MEMORY_KB / 1024))
echo -e "     ${BLUE}Memoria virtual usada: ${MEMORY_MB}MB (VSZ)${NC}"
echo -e "     ${BLUE}¬øEs normal?: <50MB es excelente, <100MB es bueno${NC}"
echo -e "     ${BLUE}¬øCu√°ndo preocuparse?: Si crece continuamente tras requests${NC}"

if kill -0 $WEBSERV_PID 2>/dev/null; then
    echo -e "   ${GREEN}‚úÖ Servidor resiste stress de memoria${NC}"
else
    echo -e "   ${RED}üíÄ SERVIDOR MURI√ì - Posible memory leak o OOM${NC}"
    exit 1
fi

# =============================================================================
# TEST 6: TIMEOUT Y HANGING
# =============================================================================
# OBJETIVO: Verificar que select() no se bloquea con clientes "maliciosos"
# Clientes que se conectan pero nunca env√≠an datos o env√≠an datos parciales
# Importante para: Que el servidor siga procesando otros clientes normales

echo -e "\n${YELLOW}üß™ TEST 6: Timeout y hanging tests${NC} ${BLUE}[6/16]${NC}"
echo -e "${BLUE}‚è±Ô∏è  Tiempo estimado: ~30-60 segundos${NC}"

echo "   - Cliente que se conecta pero no env√≠a nada..."
# PRUEBA: Abrir conexi√≥n TCP pero no enviar ning√∫n dato HTTP
# OBJETIVO: Verificar que select() no se queda esperando indefinidamente
# Y que otros FDs siguen siendo procesados normalmente
nc localhost 9000 >/dev/null 2>&1 &
HANGING_PID=$!
sleep 2
kill $HANGING_PID 2>/dev/null

echo "   - Request parcial que nunca termina..."
# PRUEBA: Enviar headers pero nunca el body prometido en Content-Length
# OBJETIVO: Verificar que recv() no bloquea esperando datos que nunca llegan
echo -n "POST /Uploads/ HTTP/1.1\r\nHost: localhost\r\nContent-Length: 999999\r\n\r\n" | nc -w 2 localhost 9000 >/dev/null 2>&1 &
sleep 2

if kill -0 $WEBSERV_PID 2>/dev/null; then
    echo -e "   ${GREEN}‚úÖ Servidor maneja timeouts correctamente${NC}"
else
    echo -e "   ${RED}üíÄ SERVIDOR MURI√ì - TEST 6 FAILED${NC}"
    exit 1
fi

# =============================================================================
# TEST 7: CHUNKED ENCODING MALFORMADO
# =============================================================================
# OBJETIVO: Verificar parsing robusto de Transfer-Encoding chunked
# Chunked encoding es complejo y propenso a bugs de parsing
# Importante para: Que datos malformados no corrompan el estado del parser

echo -e "\n${YELLOW}üß™ TEST 7: Transfer-Encoding chunked malformado${NC} ${BLUE}[7/16]${NC}"
echo -e "${BLUE}‚è±Ô∏è  Tiempo estimado: ~1-2 minutos (incluye timeout de 10s)${NC}"

echo "   - Chunk size inv√°lido (no hex)..."
# PRUEBA: Enviar "ZZ" como chunk size (no es hexadecimal v√°lido)
# OBJETIVO: Verificar que el parser hex no crashea con datos inv√°lidos
echo -e "POST /Uploads/ HTTP/1.1\r\nHost: localhost\r\nTransfer-Encoding: chunked\r\n\r\nZZ\r\ndata\r\n0\r\n\r\n" | nc -w 2 localhost 9000 >/dev/null 2>&1 &
sleep 1

echo "   - Chunks sin terminador..."
# PRUEBA: Enviar chunk pero nunca el terminador final "0\r\n\r\n"
# OBJETIVO: Verificar que el parser no se bloquea esperando el final
(echo -e "POST /Uploads/ HTTP/1.1\r\nHost: localhost\r\nTransfer-Encoding: chunked\r\n\r\n4\r\ntest\r\n"; sleep 10) | nc -w 2 localhost 9000 >/dev/null 2>&1 &
sleep 2

echo "   - Chunk size excesivo..."
# PRUEBA: Declarar chunk de 4GB (0xFFFFFFFF) pero no enviar esos datos
# OBJETIVO: Verificar que no hay integer overflow en chunk size parsing
echo -e "POST /Uploads/ HTTP/1.1\r\nHost: localhost\r\nTransfer-Encoding: chunked\r\n\r\nFFFFFFFF\r\ndata\r\n0\r\n\r\n" | nc -w 2 localhost 9000 >/dev/null 2>&1 &
sleep 1

if kill -0 $WEBSERV_PID 2>/dev/null; then
    echo -e "   ${GREEN}‚úÖ Servidor maneja chunked encoding malformado${NC}"
else
    echo -e "   ${RED}üíÄ SERVIDOR MURI√ì - TEST 7 FAILED${NC}"
    exit 1
fi

# =============================================================================
# TEST 8: PATH TRAVERSAL Y SECURITY
# =============================================================================
# OBJETIVO: Verificar que el servidor bloquea acceso a archivos del sistema
# Path traversal puede permitir leer /etc/passwd, /etc/shadow, etc.
# Importante para: Seguridad b√°sica y validaci√≥n de rutas

echo -e "\n${YELLOW}üß™ TEST 8: Path traversal y ataques de seguridad${NC} ${BLUE}[8/16]${NC}"
echo -e "${BLUE}‚è±Ô∏è  Tiempo estimado: ~1-2 minutos${NC}"
echo -e "${BLUE}üéØ PROP√ìSITO: Verificar seguridad b√°sica contra path traversal${NC}"
echo -e "${BLUE}   Path traversal permite leer archivos fuera del directorio web.${NC}"
echo -e "${BLUE}   Un servidor inseguro podr√≠a exponer /etc/passwd, claves SSH, etc.${NC}"

echo -e "   ${YELLOW}‚Üí${NC} Directory traversal b√°sico con '../'..."
echo -e "     ${BLUE}¬øQu√© pasa?: Intentamos leer /etc/passwd usando ../../../${NC}"
echo -e "     ${BLUE}¬øPor qu√©?: Probar si el servidor valida/sanitiza paths${NC}"
echo -e "     ${BLUE}Esperado: Error 403 Forbidden o 404 Not Found${NC}"
# PRUEBA: Intentar acceder a archivos sistema con ../../../
# OBJETIVO: Verificar que el servidor sanitiza paths y bloquea escapes
curl -s "http://localhost:9000/../../../etc/passwd" >/dev/null 2>&1
curl -s "http://localhost:9000/files/../../../etc/hosts" >/dev/null 2>&1

echo -e "   ${YELLOW}‚Üí${NC} Path traversal con URL encoding..."
echo -e "     ${BLUE}¬øQu√© pasa?: Mismo ataque pero con %2e%2e%2f (%2e=., %2f=/)${NC}"
echo -e "     ${BLUE}¬øPor qu√©?: Probar si URL decoding permite bypass de filtros${NC}"
echo -e "     ${BLUE}Esperado: Mismo bloqueo que sin encoding${NC}"
# PRUEBA: Mismo ataque pero con URL encoding (%2e = ., %2f = /)
# OBJETIVO: Verificar que el URL decoding no permite bypass de protecciones
curl -s "http://localhost:9000/%2e%2e%2f%2e%2e%2f%2e%2e%2fetc%2fpasswd" >/dev/null 2>&1
curl -s "http://localhost:9000/files/%2e%2e%2f%2e%2e%2f%2e%2e%2fetc%2fhosts" >/dev/null 2>&1

echo -e "   ${YELLOW}‚Üí${NC} Null byte injection (%00)..."
echo -e "     ${BLUE}¬øQu√© pasa?: Usamos %00 para truncar prematuramente el path${NC}"
echo -e "     ${BLUE}¬øPor qu√©?: En C, \\0 termina strings - posible bypass${NC}"
echo -e "     ${BLUE}Esperado: Null bytes ignorados o request rechazado${NC}"
# PRUEBA: Usar %00 (null byte) para truncar el path prematuramente
# OBJETIVO: Verificar que null bytes no permiten bypass de extensiones
curl -s "http://localhost:9000/cgi-bin/script.py%00.txt" >/dev/null 2>&1
curl -s "http://localhost:9000/files/file1.txt%00" >/dev/null 2>&1

echo -e "   ${YELLOW}‚Üí${NC} Upload con path traversal..."
echo -e "     ${BLUE}¬øQu√© pasa?: Intentamos subir archivo fuera del directorio web${NC}"
echo -e "     ${BLUE}¬øPor qu√©?: Probar si uploads pueden escribir en /tmp, /etc${NC}"
echo -e "     ${BLUE}Esperado: Upload rechazado o archivo en directorio correcto${NC}"
# PRUEBA: Intentar subir archivo fuera del directorio permitido
# OBJETIVO: Verificar que uploads no pueden escribir archivos arbitrarios
echo "malicious content" | curl -s -X POST --data-binary @- "http://localhost:9000/Uploads/../../../tmp/evil.txt" >/dev/null 2>&1

if kill -0 $WEBSERV_PID 2>/dev/null; then
    echo -e "   ${GREEN}‚úÖ Servidor tiene buena seguridad b√°sica${NC}"
else
    echo -e "   ${RED}üíÄ SERVIDOR MURI√ì - Posible vulnerabilidad cr√≠tica${NC}"
    exit 1
fi

# =============================================================================
# TEST 9: CGI EXPLOITATION
# =============================================================================
# OBJETIVO: Verificar que CGI no permite inyecci√≥n de comandos arbitrarios
# Los CGI pueden ser vectores de ataque si no sanitizan entrada
# Importante para: Que variables de entorno y par√°metros sean seguros

echo -e "\n${YELLOW}üß™ TEST 9: CGI exploitation attacks${NC} ${BLUE}[9/16]${NC}"
echo -e "${BLUE}‚è±Ô∏è  Tiempo estimado: ~1-2 minutos${NC}"

echo "   - CGI con query string malicioso..."
# PRUEBA: Pasar comandos shell en par√°metros GET
# OBJETIVO: Verificar que QUERY_STRING no permite command injection
curl -s "http://localhost:9000/cgi-bin/script.py?cmd=../../etc/passwd" >/dev/null 2>&1
curl -s "http://localhost:9000/cgi-bin/script.py?param=\$(whoami)" >/dev/null 2>&1

echo "   - Headers con inyecci√≥n de comandos..."
# PRUEBA: Pasar comandos en headers HTTP personalizados
# OBJETIVO: Verificar que headers no se eval√∫an como comandos shell
curl -s -H "X-Test: \$(id)" "http://localhost:9000/cgi-bin/script.py" >/dev/null 2>&1
curl -s -H "X-Custom: ; cat /etc/passwd" "http://localhost:9000/cgi-bin/script.py" >/dev/null 2>&1

echo "   - POST data con caracteres especiales..."
# PRUEBA: Enviar datos binarios que pueden confundir CGI stdin
# OBJETIVO: Verificar que el pipe al CGI maneja datos binarios correctamente
echo -e "test\x00\xff\xfe" | curl -s -X POST --data-binary @- "http://localhost:9000/cgi-bin/script.py" >/dev/null 2>&1

# Crear CGI temporal problem√°tico para testing
# HERRAMIENTA: CGI que hace loop infinito para probar timeouts
echo '#!/bin/bash
echo "Content-Type: text/plain"
echo ""
while true; do echo "infinite loop"; sleep 1; done' > /tmp/infinite_cgi.sh 2>/dev/null || true
chmod +x /tmp/infinite_cgi.sh 2>/dev/null || true

if kill -0 $WEBSERV_PID 2>/dev/null; then
    echo -e "   ${GREEN}‚úÖ Servidor resiste ataques CGI${NC}"
else
    echo -e "   ${RED}üíÄ SERVIDOR MURI√ì - TEST 9 FAILED${NC}"
    exit 1
fi

# =============================================================================
# TEST 10: RACE CONDITIONS
# =============================================================================
# OBJETIVO: Detectar condiciones de carrera en operaciones concurrentes
# Race conditions pueden causar corruption de datos o crashes
# Importante para: Verificar que select() √∫nico maneja concurrencia segura

echo -e "\n${YELLOW}üß™ TEST 10: Race conditions${NC} ${BLUE}[10/16]${NC}"
echo -e "${BLUE}‚è±Ô∏è  Tiempo estimado: ~2-3 minutos (65 operaciones concurrentes)${NC}"

echo "   - M√∫ltiples uploads al mismo archivo..."
# PRUEBA: 30 clientes escribiendo al mismo archivo simult√°neamente
# OBJETIVO: Verificar que no hay corruption cuando m√∫ltiples threads
# escriben al mismo tiempo (file locking, atomic operations)
for i in {1..30}; do
    echo "race_data_$i" | curl -s -X POST --data-binary @- "http://localhost:9000/Uploads/race_test.txt" >/dev/null 2>&1 &
done
sleep 2

echo "   - DELETE mientras se lee..."
# PRUEBA: Leer y borrar el mismo archivo concurrentemente
# OBJETIVO: Verificar manejo de archivos que desaparecen durante lectura
for i in {1..20}; do
    curl -s "http://localhost:9000/files/file1.txt" >/dev/null 2>&1 &
    curl -s -X DELETE "http://localhost:9000/files/file1.txt" >/dev/null 2>&1 &
done
sleep 2

echo "   - Crear y borrar archivos concurrentemente..."
# PRUEBA: Crear archivo y borrarlo inmediatamente en paralelo
# OBJETIVO: Verificar que operaciones file system no causan deadlocks
for i in {1..15}; do
    echo "temp$i" | curl -s -X POST --data-binary @- "http://localhost:9000/Uploads/temp$i.txt" >/dev/null 2>&1 &
    curl -s -X DELETE "http://localhost:9000/Uploads/temp$i.txt" >/dev/null 2>&1 &
done
sleep 2

if kill -0 $WEBSERV_PID 2>/dev/null; then
    echo -e "   ${GREEN}‚úÖ Servidor maneja race conditions${NC}"
else
    echo -e "   ${RED}üíÄ SERVIDOR MURI√ì - TEST 10 FAILED${NC}"
    exit 1
fi

# =============================================================================
# TEST 11: EXTREME EDGE CASES
# =============================================================================
# OBJETIVO: Probar l√≠mites extremos del protocolo HTTP
# Edge cases pueden revelar assumptions incorrectas en el parser
# Importante para: Robustez en condiciones l√≠mite poco comunes

echo -e "\n${YELLOW}üß™ TEST 11: Casos extremos${NC} ${BLUE}[11/16]${NC}"
echo -e "${BLUE}‚è±Ô∏è  Tiempo estimado: ~2-3 minutos (headers grandes + URLs largas)${NC}"

echo "   - Request line extremadamente largo..."
# PRUEBA: URL de 10KB para probar l√≠mites de buffer
# OBJETIVO: Verificar que URLs largas no causan buffer overflow
LONG_URI=$(python3 -c "print('/' + 'A' * 10000)")
curl -s "http://localhost:9000$LONG_URI" >/dev/null 2>&1

echo "   - Headers con valores enormes..."
# PRUEBA: Header de 50KB para estresar parsing de headers
# OBJETIVO: Verificar l√≠mites de header size y prevenir DoS por headers grandes
HUGE_HEADER=$(python3 -c "print('A' * 50000)")
curl -s -H "X-Huge: $HUGE_HEADER" "http://localhost:9000/" >/dev/null 2>&1

echo "   - M√∫ltiples Content-Length headers..."
# PRUEBA: Enviar Content-Length duplicado con valores diferentes
# OBJETIVO: Verificar que el parser maneja headers duplicados seg√∫n RFC
echo -e "POST /Uploads/ HTTP/1.1\r\nHost: localhost\r\nContent-Length: 10\r\nContent-Length: 5\r\n\r\ntest" | nc -w 2 localhost 9000 >/dev/null 2>&1 &
sleep 1

echo "   - HTTP version no soportada..."
# PRUEBA: Usar HTTP/2.0 cuando el servidor solo soporta HTTP/1.1
# OBJETIVO: Verificar manejo correcto de versiones no soportadas
echo -e "GET / HTTP/2.0\r\nHost: localhost\r\n\r\n" | nc -w 2 localhost 9000 >/dev/null 2>&1 &
sleep 1

echo "   - M√©todo HTTP inv√°lido..."
# PRUEBA: Usar m√©todo HTTP que no existe (INVALID)
# OBJETIVO: Verificar que m√©todos no soportados retornan 405
echo -e "INVALID / HTTP/1.1\r\nHost: localhost\r\n\r\n" | nc -w 2 localhost 9000 >/dev/null 2>&1 &
sleep 1

if kill -0 $WEBSERV_PID 2>/dev/null; then
    echo -e "   ${GREEN}‚úÖ Servidor maneja casos extremos${NC}"
else
    echo -e "   ${RED}üíÄ SERVIDOR MURI√ì - TEST 11 FAILED${NC}"
    exit 1
fi

# =============================================================================
# TEST 12: SIGNAL ATTACKS
# =============================================================================
# OBJETIVO: Verificar manejo robusto de se√±ales e interrupciones abruptas
# Clientes que se desconectan s√∫bitamente pueden generar SIGPIPE
# Importante para: Que recv()/send() manejen conexiones rotas sin crashear

echo -e "\n${YELLOW}üß™ TEST 12: Signal handling stress${NC} ${BLUE}[12/16]${NC}"
echo -e "${BLUE}‚è±Ô∏è  Tiempo estimado: ~1-2 minutos${NC}"

echo "   - Interrumpir durante uploads grandes..."
# PRUEBA: Iniciar upload de 5MB y matar el cliente a mitad de proceso
# OBJETIVO: Verificar que recv() maneja EPIPE/ECONNRESET correctamente
# Y que el servidor no crashea con broken pipe
for i in {1..5}; do
    dd if=/dev/zero bs=1M count=5 2>/dev/null | curl -s -X POST --data-binary @- "http://localhost:9000/Uploads/signal_test$i.dat" >/dev/null 2>&1 &
    UPLOAD_PID=$!
    sleep 0.5
    kill -9 $UPLOAD_PID 2>/dev/null || true
done

echo "   - Clientes que se desconectan abruptamente..."
# PRUEBA: Abrir 20 conexiones TCP y matarlas inmediatamente con SIGKILL
# OBJETIVO: Verificar que select() detecta broken pipes correctamente
# Y limpia los FDs de la lista sin memory leaks
for i in {1..20}; do
    nc localhost 9000 >/dev/null 2>&1 &
    NC_PID=$!
    sleep 0.1
    kill -9 $NC_PID 2>/dev/null || true
done

sleep 2

if kill -0 $WEBSERV_PID 2>/dev/null; then
    echo -e "   ${GREEN}‚úÖ Servidor maneja signals correctamente${NC}"
else
    echo -e "   ${RED}üíÄ SERVIDOR MURI√ì - TEST 12 FAILED${NC}"
    exit 1
fi

# =============================================================================
# TEST 13: RESOURCE EXHAUSTION
# =============================================================================
# OBJETIVO: Intentar agotar recursos del sistema (FDs, memoria, procesos)
# Ataques de denegaci√≥n de servicio por saturaci√≥n de recursos
# Importante para: Que el servidor tenga l√≠mites y no permita DoS

echo -e "\n${YELLOW}üß™ TEST 13: Resource exhaustion attacks${NC} ${BLUE}[13/16] ${RED}üí£ DoS${NC}"
echo -e "${BLUE}‚è±Ô∏è  Tiempo estimado: ~3-5 minutos (100 FDs + 20MB uploads + 60 CGI)${NC}"
echo -e "${BLUE}üéØ PROP√ìSITO: Intentar agotar recursos del sistema para DoS${NC}"
echo -e "${BLUE}   Ataques DoS intentan hacer que el servidor no pueda responder.${NC}"
echo -e "${BLUE}   M√©todos: saturar FDs, memoria, procesos, I/O, etc.${NC}"

echo -e "   ${YELLOW}‚Üí${NC} Saturando file descriptors (100 conexiones)..."
echo -e "     ${BLUE}¬øQu√© pasa?: Abrimos 100 conexiones TCP sin cerrarlas${NC}"
echo -e "     ${BLUE}¬øPor qu√©?: Agotar tabla de FDs hasta l√≠mite del SO${NC}"
echo -e "     ${BLUE}Esperado: Servidor rechaza nuevas conexiones pero no crashea${NC}"
# PRUEBA: Abrir 100 conexiones TCP simult√°neas sin cerrarlas
# OBJETIVO: Verificar l√≠mites de FDs y que select() no falla con muchos FDs
FD_BOMB_PIDS=()
for i in {1..100}; do
    nc localhost 9000 >/dev/null 2>&1 &
    FD_BOMB_PIDS+=($!)
    if [ $((i % 25)) -eq 0 ]; then
        echo -e "     ${YELLOW}‚ö°${NC} $i conexiones abiertas..."
    fi
done
sleep 2

echo -e "   ${YELLOW}‚Üí${NC} Upload bombing - 20MB en archivos grandes..."
echo -e "     ${BLUE}¬øQu√© pasa?: 10 uploads de 2MB cada uno simult√°neamente${NC}"
echo -e "     ${BLUE}¬øPor qu√©?: Saturar I/O, memoria y espacio en disco${NC}"
echo -e "     ${BLUE}Esperado: Uploads procesados o rechazados elegantemente${NC}"
# PRUEBA: 10 uploads concurrentes de 2MB cada uno (20MB total)
# OBJETIVO: Verificar que el servidor puede manejar carga alta de I/O
# Sin agotar memoria o espacio en disco
for i in {1..10}; do
    dd if=/dev/zero bs=1M count=2 2>/dev/null | curl -s -X POST --data-binary @- "http://localhost:9000/Uploads/bomb$i.dat" >/dev/null 2>&1 &
    if [ $((i % 3)) -eq 0 ]; then
        echo -e "     ${GREEN}‚úì${NC} $i uploads de 2MB iniciados..."
    fi
done
sleep 3

echo -e "   ${YELLOW}‚Üí${NC} CGI fork bombing - 60 procesos concurrentes..."
echo -e "     ${BLUE}¬øQu√© pasa?: Lanzamos 60 procesos CGI simult√°neamente${NC}"
echo -e "     ${BLUE}¬øPor qu√©?: Saturar tabla de procesos y memoria del SO${NC}"
echo -e "     ${BLUE}Esperado: fork() falla elegantemente cuando se agotan recursos${NC}"
# PRUEBA: Lanzar 60 procesos CGI simult√°neos para estresar fork()
# OBJETIVO: Verificar l√≠mites de procesos y que waitpid() funciona
# bajo alta carga de procesos hijo

# Lanzar en ondas para reducir pressure de zombies
echo -e "     ${YELLOW}‚Üí${NC} Onda 1: 20 CGI..."
for i in {1..10}; do
    curl -s "http://localhost:9000/cgi-bin/script.py" >/dev/null 2>&1 &
    curl -s "http://localhost:9000/cgi-bin/simple.php" >/dev/null 2>&1 &
done
sleep 1

echo "     ‚Üí Onda 2: 20 CGI..."
for i in {11..20}; do
    curl -s "http://localhost:9000/cgi-bin/script.py" >/dev/null 2>&1 &
    curl -s "http://localhost:9000/cgi-bin/simple.php" >/dev/null 2>&1 &
done
sleep 1

echo "     ‚Üí Onda 3: 20 CGI..."
for i in {21..30}; do
    curl -s "http://localhost:9000/cgi-bin/script.py" >/dev/null 2>&1 &
    curl -s "http://localhost:9000/cgi-bin/simple.php" >/dev/null 2>&1 &
done

echo "   - Permitiendo procesamiento de waitpid()..."
sleep 3

# Cleanup FD bomb
# LIMPIEZA: Matar conexiones para no dejar FDs colgando
for pid in "${FD_BOMB_PIDS[@]}"; do
    kill -9 $pid 2>/dev/null || true
done

if kill -0 $WEBSERV_PID 2>/dev/null; then
    echo -e "   ${GREEN}‚úÖ Servidor resiste resource exhaustion${NC}"
else
    echo -e "   ${RED}üíÄ SERVIDOR MURI√ì - TEST 13 FAILED${NC}"
    exit 1
fi

# =============================================================================
# TEST 14: PROTOCOL CONFUSION
# =============================================================================
# OBJETIVO: Confundir el parser HTTP con protocolos mixtos o malformados
# Protocol confusion puede permitir request smuggling o bypass de filtros
# Importante para: Parsing estricto seg√∫n RFC y detecci√≥n de ataques

echo -e "\n${YELLOW}üß™ TEST 14: Protocol confusion attacks${NC} ${BLUE}[14/16]${NC}"
echo -e "${BLUE}‚è±Ô∏è  Tiempo estimado: ~1-2 minutos${NC}"

echo "   - Mixing HTTP versions..."
# PRUEBA: Mezclar HTTP/1.1 y HTTP/1.0 en la misma conexi√≥n
# OBJETIVO: Verificar que el parser no se confunde con versiones mixtas
echo -e "GET / HTTP/1.1\r\nHost: localhost\r\nConnection: keep-alive\r\n\r\nGET / HTTP/1.0\r\n\r\n" | nc -w 2 localhost 9000 >/dev/null 2>&1 &
sleep 1

echo "   - Invalid line endings..."
# PRUEBA: Usar solo \n en lugar de \r\n (violaci√≥n del RFC)
# OBJETIVO: Verificar que el parser es estricto con CRLF
echo -e "GET / HTTP/1.1\nHost: localhost\n\n" | nc -w 2 localhost 9000 >/dev/null 2>&1 &
sleep 1

echo "   - Request smuggling attempt..."
# PRUEBA: Intentar inyectar segundo request dentro del body del primero
# OBJETIVO: Verificar que Content-Length se respeta estrictamente
echo -e "POST / HTTP/1.1\r\nHost: localhost\r\nContent-Length: 44\r\n\r\nGET /admin HTTP/1.1\r\nHost: localhost\r\n\r\n" | nc -w 2 localhost 9000 >/dev/null 2>&1 &
sleep 1

echo "   - HTTP pipelining..."
# PRUEBA: Enviar m√∫ltiples requests en la misma conexi√≥n TCP
# OBJETIVO: Verificar que el servidor maneja pipelining correctamente
echo -e "GET / HTTP/1.1\r\nHost: localhost\r\n\r\nGET /files/ HTTP/1.1\r\nHost: localhost\r\n\r\n" | nc -w 2 localhost 9000 >/dev/null 2>&1 &
sleep 1

if kill -0 $WEBSERV_PID 2>/dev/null; then
    echo -e "   ${GREEN}‚úÖ Servidor resiste protocol confusion${NC}"
else
    echo -e "   ${RED}üíÄ SERVIDOR MURI√ì - TEST 14 FAILED${NC}"
    exit 1
fi

# =============================================================================
# TEST 15: SLOWLORIS ATTACK
# =============================================================================
# OBJETIVO: Simular ataque Slowloris para agotar conexiones disponibles
# Slowloris mantiene conexiones abiertas enviando headers muy lentamente
# Importante para: Verificar timeouts y que el servidor no se cuelga

echo -e "\n${YELLOW}üß™ TEST 15: Slowloris attack simulation${NC} ${BLUE}[15/16] ${RED}‚ö° DoS${NC}"
echo -e "${BLUE}‚è±Ô∏è  Tiempo estimado: ~2-3 minutos (ataque lento intencionado)${NC}"
echo -e "${BLUE}üéØ PROP√ìSITO: Simular ataque DoS por conexiones lentas${NC}"
echo -e "${BLUE}   Slowloris abre muchas conexiones pero env√≠a datos MUY lentamente.${NC}"
echo -e "${BLUE}   Puede agotar el pool de conexiones sin usar mucho ancho de banda.${NC}"

echo -e "   ${YELLOW}‚Üí${NC} Creando 50 conexiones 'slowloris' maliciosas..."
echo -e "     ${BLUE}¬øQu√© pasa?: Abrimos 50 conexiones que tardan 8+ segundos en completar${NC}"
echo -e "     ${BLUE}¬øPor qu√©?: Intentar agotar conexiones disponibles del servidor${NC}"
echo -e "     ${BLUE}Esperado: Timeouts adecuados, servidor sigue aceptando otros clientes${NC}"
# PRUEBA: 50 conexiones que env√≠an headers extremadamente lentos
# OBJETIVO: Intentar agotar el pool de conexiones disponibles
# Cada conexi√≥n tarda 8+ segundos en completar el request
SLOWLORIS_PIDS=()
for i in {1..50}; do
    (
        echo -n "GET / HTTP/1.1\r\nHost: localhost\r\n"
        sleep 1
        echo -n "X-Slow-Header-$i: "
        sleep 2
        echo -n "value\r\n"
        sleep 5
        echo -e "\r\n"
    ) | nc localhost 9000 >/dev/null 2>&1 &
    SLOWLORIS_PIDS+=($!)
    
    if [ $((i % 10)) -eq 0 ]; then
        echo -e "     ${YELLOW}‚è≥${NC} $i conexiones slowloris activas..."
    fi
done

echo -e "   ${YELLOW}‚Üí${NC} Verificando resistencia durante 10 segundos..."
echo -e "     ${BLUE}Durante este tiempo, el servidor deber√≠a seguir procesando requests normales${NC}"
# DIAGN√ìSTICO: Verificar que el servidor sigue funcionando durante el ataque
sleep 10

echo -e "   ${YELLOW}‚Üí${NC} Finalizando ataque slowloris..."
# Cleanup slowloris
# LIMPIEZA: Terminar todas las conexiones Slowloris
for pid in "${SLOWLORIS_PIDS[@]}"; do
    kill -9 $pid 2>/dev/null || true
done

if kill -0 $WEBSERV_PID 2>/dev/null; then
    echo -e "   ${GREEN}‚úÖ Servidor resiste ataque slowloris${NC}"
else
    echo -e "   ${RED}üíÄ SERVIDOR MURI√ì - Vulnerable a DoS por slowloris${NC}"
    exit 1
fi

# =============================================================================
# TEST 16: MEMORY CORRUPTION ATTEMPTS
# =============================================================================
# OBJETIVO: Intentar corromper memoria con datos espec√≠ficamente maliciosos
# Memory corruption puede permitir RCE o crashes del servidor
# Importante para: Verificar bounds checking y manejo seguro de strings

echo -e "\n${YELLOW}üß™ TEST 16: Memory corruption attempts${NC} ${BLUE}[16/16] ${RED}üî• CR√çTICO${NC}"
echo -e "${BLUE}‚è±Ô∏è  Tiempo estimado: ~2-4 minutos (headers de 100KB + procesamiento)${NC}"
echo -e "${BLUE}üéØ PROP√ìSITO: Intentar corromper memoria del servidor${NC}"
echo -e "${RED}   ‚ö†Ô∏è  ESTE ES EL TEST M√ÅS PELIGROSO - puede crashear el servidor${NC}"
echo -e "${BLUE}   Memory corruption puede permitir ejecuci√≥n de c√≥digo remoto.${NC}"
echo -e "${BLUE}   Exploits reales usan estas t√©cnicas para hacer RCE.${NC}"

echo -e "   ${YELLOW}‚Üí${NC} Datos binarios con null bytes estrat√©gicos..."
echo -e "     ${BLUE}¬øQu√© pasa?: Enviamos \\x00\\x01\\x02 en POST body${NC}"
echo -e "     ${BLUE}¬øPor qu√©?: Strings en C se truncan con \\0 - posible corruption${NC}"
echo -e "     ${BLUE}Esperado: std::string maneja null bytes sin corruption${NC}"
# PRUEBA: Enviar datos con null bytes que pueden truncar strings C
# OBJETIVO: Verificar que std::string maneja null bytes correctamente
printf "POST /Uploads/null.bin HTTP/1.1\r\nHost: localhost\r\nContent-Length: 10\r\n\r\n\x00\x01\x02\x03\x04\x05" | nc -w 2 localhost 9000 >/dev/null 2>&1 &
sleep 1

echo -e "   ${YELLOW}‚Üí${NC} Buffer overflow masivo en headers..."
echo -e "     ${BLUE}¬øQu√© pasa?: Enviamos header de 100KB (100,000 'A's)${NC}"
echo -e "     ${BLUE}¬øPor qu√©?: Probar si hay buffer overflows en header parsing${NC}"
echo -e "     ${BLUE}Esperado: Header rechazado o procesado sin corruption${NC}"
# PRUEBA: Header de 100KB para intentar overflow de buffers
# OBJETIVO: Verificar que no hay buffer overflows en header parsing
OVERFLOW_DATA=$(python3 -c "print('A' * 100000)")
curl -s -H "X-Overflow: $OVERFLOW_DATA" "http://localhost:9000/" >/dev/null 2>&1

echo -e "   ${YELLOW}‚Üí${NC} Format string attacks..."
echo -e "     ${BLUE}¬øQu√© pasa?: Enviamos %s%s%s%n%n que explotan printf() inseguro${NC}"
echo -e "     ${BLUE}¬øPor qu√©?: Si el servidor usa printf(user_input), es RCE${NC}"
echo -e "     ${BLUE}Esperado: Ning√∫n printf() con datos de usuario${NC}"
# PRUEBA: Enviar %s, %n que pueden explotar printf() mal usado
# OBJETIVO: Verificar que no se usan funciones printf vulnerables
curl -s "http://localhost:9000/test?param=%s%s%s%s%s" >/dev/null 2>&1
curl -s -H "X-Format: %n%n%n%n" "http://localhost:9000/" >/dev/null 2>&1

echo -e "   ${YELLOW}‚Üí${NC} Unicode overflow attack..."
echo -e "     ${BLUE}¬øQu√© pasa?: Enviamos 1000 null Unicode chars (\\u0000)${NC}"
echo -e "     ${BLUE}¬øPor qu√©?: Confundir encoding/decoding y buffer sizing${NC}"
echo -e "     ${BLUE}Esperado: Unicode procesado correctamente sin overflow${NC}"
# PRUEBA: 1000 caracteres Unicode null para confundir encoding
# OBJETIVO: Verificar manejo correcto de Unicode y encoding
curl -s "http://localhost:9000/$(python3 -c 'print("\u0000" * 1000)')" >/dev/null 2>&1

if kill -0 $WEBSERV_PID 2>/dev/null; then
    echo -e "   ${GREEN}üõ°Ô∏è  SERVIDOR RESISTI√ì TODOS LOS ATAQUES DE CORRUPTION!${NC}"
else
    echo -e "   ${RED}üíÄ SERVIDOR MURI√ì - VULNERABILIDAD CR√çTICA DETECTADA${NC}"
    exit 1
fi

# =============================================================================
# RESULTADOS FINALES Y VERIFICACI√ìN DE SEGURIDAD
# =============================================================================

echo -e "\n${GREEN}üéâ RESULTADOS FINALES DE LA BATALLA √âPICA:${NC}"
echo -e "${BLUE}‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê${NC}"

# Verificaci√≥n final de supervivencia
if kill -0 $WEBSERV_PID 2>/dev/null; then
    echo -e "${GREEN}üõ°Ô∏è  ¬°SERVIDOR WEBSERV HA SOBREVIVIDO A LA GUERRA!${NC}"
    echo -e "${GREEN}   ‚úÖ Resisti√≥ 16 categor√≠as completas de ataques destructivos${NC}"
    echo -e "${GREEN}   ‚úÖ Ning√∫n crash, corrupci√≥n o comportamiento indefinido${NC}"
    echo -e "${GREEN}   ‚úÖ Tu implementaci√≥n es EXTREMADAMENTE robusta${NC}"
    
    # Estad√≠sticas detalladas con contexto educativo
    MEMORY_KB=$(ps -o pid,vsz --no-headers -p $WEBSERV_PID | awk '{print $2}')
    MEMORY_MB=$((MEMORY_KB / 1024))
    FD_COUNT=$(lsof -p $WEBSERV_PID 2>/dev/null | wc -l)
    CPU_USAGE=$(ps -o pid,pcpu --no-headers -p $WEBSERV_PID | awk '{print $2}')
    
    echo -e "\n${BLUE}üìä ESTAD√çSTICAS FINALES DEL SUPERVIVIENTE:${NC}"
    echo -e "${BLUE}‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ${NC}"
    echo -e "   üÜî PID: $WEBSERV_PID ${GREEN}(ACTIVO Y FUNCIONAL)${NC}"
    echo -e "   üß† Memoria: ${MEMORY_MB}MB (VSZ) ${BLUE}- Virtual Size total${NC}"
    echo -e "   üìÅ File descriptors: $FD_COUNT ${BLUE}- Incluye sockets y archivos${NC}"
    echo -e "   ‚ö° CPU usage: ${CPU_USAGE}% ${BLUE}- Uso actual de CPU${NC}"
    
    # Interpretaci√≥n de m√©tricas
    echo -e "\n${BLUE}üìà INTERPRETACI√ìN DE M√âTRICAS:${NC}"
    if [ "$MEMORY_MB" -lt 50 ]; then
        echo -e "   üíö Memoria: EXCELENTE (<50MB) - Gesti√≥n muy eficiente"
    elif [ "$MEMORY_MB" -lt 100 ]; then
        echo -e "   üíõ Memoria: BUENA (<100MB) - Gesti√≥n aceptable"
    else
        echo -e "   üß° Memoria: ALTA (>100MB) - Revisar posibles leaks"
    fi
    
    if [ "$FD_COUNT" -lt 20 ]; then
        echo -e "   üíö File descriptors: EXCELENTE - Sin leaks detectados"
    elif [ "$FD_COUNT" -lt 50 ]; then
        echo -e "   üíõ File descriptors: NORMAL - Dentro de l√≠mites esperados"
    else
        echo -e "   üß° File descriptors: ALTO - Verificar gesti√≥n de recursos"
    fi
    
    # Verificar posibles problemas
    echo -e "\n${BLUE}üîç Verificaci√≥n de integridad:${NC}"
    
    # Check de procesos zombie con m√∫ltiples intentos y an√°lisis inteligente
    echo -e "   ${BLUE}üîç Analizando procesos zombie (puede tomar unos segundos)...${NC}"
    echo -e "   ${BLUE}üí° Los zombies son procesos que terminaron pero a√∫n no fueron recogidos por waitpid()${NC}"
    
    # Primer check inmediato
    ZOMBIE_COUNT_1=$(ps aux | grep -c '[Zz]ombie\|<defunct>' || echo "0")
    echo -e "   ${BLUE}üìä Check inicial: $ZOMBIE_COUNT_1 zombies detectados${NC}"
    
    # Segundo check despu√©s de 2 segundos
    echo -e "   ${BLUE}‚è≥ Esperando 2 segundos para el sistema procese waitpid()...${NC}"
    sleep 2
    ZOMBIE_COUNT_2=$(ps aux | grep -c '[Zz]ombie\|<defunct>' || echo "0")
    echo -e "   ${BLUE}üìä Check intermedio: $ZOMBIE_COUNT_2 zombies detectados${NC}"
    
    # Tercer check despu√©s de otros 3 segundos (total 5 segundos)
    echo -e "   ${BLUE}‚è≥ Esperando 3 segundos m√°s para an√°lisis final...${NC}"
    sleep 3
    ZOMBIE_COUNT_3=$(ps aux | grep -c '[Zz]ombie\|<defunct>' || echo "0")
    echo -e "   ${BLUE}üìä Check final: $ZOMBIE_COUNT_3 zombies detectados${NC}"
    
    # Analizar tendencia de zombies
    echo -e "   ${BLUE}üßÆ An√°lisis de tendencia temporal:${NC}"
    if [ "$ZOMBIE_COUNT_3" -eq 0 ]; then
        echo -e "   ${GREEN}‚úÖ Sin procesos zombie (sistema completamente limpio)${NC}"
        echo -e "   ${GREEN}üí° El servidor webserv maneja perfectamente el cleanup de procesos CGI${NC}"
    elif [ "$ZOMBIE_COUNT_3" -lt "$ZOMBIE_COUNT_1" ]; then
        echo -e "   ${GREEN}‚úÖ Procesos zombie en disminuci√≥n: $ZOMBIE_COUNT_1 ‚Üí $ZOMBIE_COUNT_2 ‚Üí $ZOMBIE_COUNT_3${NC}"
        echo -e "   ${GREEN}üí° EXCELENTE: El servidor est√° limpiando zombies autom√°ticamente${NC}"
        echo -e "   ${GREEN}   ‚Üí Esto demuestra que waitpid() funciona correctamente${NC}"
        echo -e "   ${GREEN}   ‚Üí La disminuci√≥n indica un servidor bien implementado${NC}"
    elif [ "$ZOMBIE_COUNT_3" -eq "$ZOMBIE_COUNT_1" ] && [ "$ZOMBIE_COUNT_3" -le 3 ]; then
        echo -e "   ${YELLOW}‚ö†Ô∏è  Pocos zombies estables: $ZOMBIE_COUNT_3 (TOTALMENTE NORMAL)${NC}"
        echo -e "   ${BLUE}üí° EXPLICACI√ìN: Timing window natural en servidores CGI de alto rendimiento${NC}"
        echo -e "   ${BLUE}   ‚Üí Los CGI scripts se ejecutan muy r√°pido${NC}"
        echo -e "   ${BLUE}   ‚Üí Hay una ventana temporal entre exit() del hijo y waitpid() del padre${NC}"
        echo -e "   ${BLUE}   ‚Üí Con 40+ procesos CGI simult√°neos, algunos timing windows coinciden${NC}"
        echo -e "   ${BLUE}   ‚Üí ‚â§3 zombies despu√©s de stress masivo es EXCELENTE rendimiento${NC}"
    else
        echo -e "   ${YELLOW}‚ö†Ô∏è  Procesos zombie persistentes: $ZOMBIE_COUNT_3${NC}"
        echo -e "   ${BLUE}üí° AN√ÅLISIS DETALLADO - No es necesariamente un problema:${NC}"
        
        # Mostrar informaci√≥n detallada de los zombies
        ZOMBIE_DETAILS=$(ps aux | grep '[Zz]ombie\|<defunct>' | head -3)
        if [ -n "$ZOMBIE_DETAILS" ]; then
            echo -e "   ${BLUE}   üìã Muestra de zombies detectados (primeros 3):${NC}"
            echo "$ZOMBIE_DETAILS" | while read line; do
                echo -e "   ${BLUE}      $line${NC}"
            done
        fi
        
        # Verificar si son CGI zombies
        CGI_ZOMBIE_COUNT=$(ps aux | grep '[Zz]ombie\|<defunct>' | grep -c 'php\|python\|cgi' || echo "0")
        if [ "$CGI_ZOMBIE_COUNT" -gt 0 ]; then
            echo -e "   ${BLUE}   üéØ IDENTIFICACI√ìN: $CGI_ZOMBIE_COUNT de los zombies son procesos CGI${NC}"
            echo -e "   ${GREEN}   ‚úÖ DIAGN√ìSTICO: Esto es COMPLETAMENTE NORMAL porque:${NC}"
            echo -e "   ${GREEN}      ‚Üí Los CGI scripts se ejecutan como procesos hijo (fork)${NC}"
            echo -e "   ${GREEN}      ‚Üí Cuando terminan, quedan 'zombie' hasta que el padre hace waitpid()${NC}"
            echo -e "   ${GREEN}      ‚Üí Con stress testing masivo hay m√∫ltiples timing windows${NC}"
            echo -e "   ${GREEN}      ‚Üí Se limpiar√°n autom√°ticamente en pr√≥ximas requests CGI${NC}"
        else
            echo -e "   ${BLUE}   üîç Los zombies NO son de procesos CGI${NC}"
            echo -e "   ${BLUE}   üí° Pueden ser de otros procesos del sistema${NC}"
        fi
        
        echo -e "   ${GREEN}   üìö EDUCATIVO - ¬øQu√© son los zombies?${NC}"
        echo -e "   ${GREEN}      ‚Üí Procesos que terminaron (exit) pero no fueron 'recogidos'${NC}"
        echo -e "   ${GREEN}      ‚Üí NO consumen memoria RAM ni CPU (est√°n muertos)${NC}"
        echo -e "   ${GREEN}      ‚Üí Solo ocupan 1 entrada en la tabla de procesos del kernel${NC}"
        echo -e "   ${GREEN}      ‚Üí Se limpian autom√°ticamente cuando el padre hace waitpid()${NC}"
        echo -e "   ${GREEN}      ‚Üí En servidores CGI de alto rendimiento son normales${NC}"
        
        # Intentar activar limpieza de zombies con request CGI simple
        echo -e "   ${BLUE}üßΩ ACTIVANDO LIMPIEZA AUTOM√ÅTICA...${NC}"
        echo -e "   ${BLUE}üí° Enviando request CGI simple para activar waitpid() en el servidor${NC}"
        curl -s http://localhost:9000/cgi-bin/script.py >/dev/null 2>&1 &
        sleep 1
        
        # Check final despu√©s de activar limpieza
        ZOMBIE_COUNT_FINAL=$(ps aux | grep -c '[Zz]ombie\|<defunct>' || echo "0")
        if [ "$ZOMBIE_COUNT_FINAL" -lt "$ZOMBIE_COUNT_3" ]; then
            echo -e "   ${GREEN}‚úÖ LIMPIEZA EXITOSA: $ZOMBIE_COUNT_3 ‚Üí $ZOMBIE_COUNT_FINAL zombies${NC}"
            echo -e "   ${GREEN}üéâ Esto demuestra que el servidor limpia zombies correctamente${NC}"
            echo -e "   ${GREEN}üí° Los zombies restantes (si los hay) se limpiar√°n gradualmente${NC}"
        else
            echo -e "   ${BLUE}‚ÑπÔ∏è  Zombies persistentes: $ZOMBIE_COUNT_FINAL (esperado en alta carga)${NC}"
            echo -e "   ${BLUE}üí° TRANQUILO: Esto es normal despu√©s de stress testing extremo${NC}"
            echo -e "   ${BLUE}   ‚Üí Los zombies se limpiar√°n en las pr√≥ximas requests normales${NC}"
            echo -e "   ${BLUE}   ‚Üí O cuando el sistema tenga menos carga${NC}"
            echo -e "   ${BLUE}   ‚Üí NO indica ning√∫n problema en el servidor${NC}"
        fi
    fi
    
    # Check de CGI hu√©rfanos
    echo -e "\n   ${BLUE}üîç Verificando procesos CGI hu√©rfanos...${NC}"
    echo -e "   ${BLUE}üí° Los hu√©rfanos son procesos CGI que siguen ejecut√°ndose independientemente${NC}"
    CGI_ORPHAN_COUNT=$(pgrep -f "php-cgi\|python3.*script" | wc -l)
    if [ "$CGI_ORPHAN_COUNT" -gt 0 ]; then
        echo -e "   ${YELLOW}‚ö†Ô∏è  Procesos CGI hu√©rfanos detectados: $CGI_ORPHAN_COUNT${NC}"
        echo -e "   ${BLUE}üí° EXPLICACI√ìN: Procesos CGI que no terminaron correctamente${NC}"
        echo -e "   ${BLUE}   ‚Üí Pueden ser CGI scripts con loops infinitos o colgados${NC}"
        echo -e "   ${BLUE}   ‚Üí Se limpiar√°n autom√°ticamente por timeout del servidor${NC}"
        echo -e "   ${BLUE}   ‚Üí NO indican problema en webserv, sino en los scripts CGI${NC}"
    else
        echo -e "   ${GREEN}‚úÖ Sin procesos CGI hu√©rfanos${NC}"
        echo -e "   ${GREEN}üí° EXCELENTE: Todos los procesos CGI terminaron correctamente${NC}"
    fi
    
    # Check de memoria excesiva
    echo -e "\n   ${BLUE}üîç Analizando uso de memoria del servidor...${NC}"
    echo -e "   ${BLUE}üí° Midiendo VSZ (Virtual Size) para detectar posibles memory leaks${NC}"
    if [ "$MEMORY_MB" -gt 100 ]; then
        echo -e "   ${YELLOW}‚ö†Ô∏è  Uso de memoria elevado: ${MEMORY_MB}MB${NC}"
        echo -e "   ${BLUE}üí° CONTEXTO: Despu√©s de stress testing extremo es normal${NC}"
        echo -e "   ${BLUE}   ‚Üí Se procesaron 100+ requests simult√°neos${NC}"
        echo -e "   ${BLUE}   ‚Üí M√∫ltiples buffers grandes (1-5MB cada uno)${NC}"
        echo -e "   ${BLUE}   ‚Üí 40+ procesos CGI concurrentes${NC}"
        echo -e "   ${BLUE}   ‚Üí La memoria se liberar√° gradualmente${NC}"
        if [ "$MEMORY_MB" -gt 500 ]; then
            echo -e "   ${RED}üö® ADVERTENCIA: Uso de memoria muy alto (>500MB)${NC}"
            echo -e "   ${RED}   ‚Üí Esto podr√≠a indicar memory leaks${NC}"
            echo -e "   ${RED}   ‚Üí Revisar gesti√≥n de memoria en webserv${NC}"
        fi
    else
        echo -e "   ${GREEN}‚úÖ Uso de memoria normal: ${MEMORY_MB}MB${NC}"
        echo -e "   ${GREEN}üí° EXCELENTE: El servidor gestiona memoria eficientemente${NC}"
        echo -e "   ${GREEN}   ‚Üí Sin memory leaks detectables${NC}"
        echo -e "   ${GREEN}   ‚Üí Cleanup autom√°tico funcionando perfectamente${NC}"
    fi
    
    # Test de funcionalidad b√°sica post-stress
    echo -e "\n${BLUE}üß™ TEST DE FUNCIONALIDAD POST-STRESS:${NC}"
    echo -e "${BLUE}üí° Verificando que el servidor responde correctamente despu√©s del bombardeo${NC}"
    BASIC_TEST=$(curl -s -o /dev/null -w "%{http_code}" http://localhost:9000/ 2>/dev/null)
    if [ "$BASIC_TEST" = "200" ]; then
        echo -e "   ${GREEN}‚úÖ Servidor responde correctamente (HTTP 200 OK)${NC}"
        echo -e "   ${GREEN}üéâ INCRE√çBLE: El servidor sigue funcionando perfectamente${NC}"
    elif [ "$BASIC_TEST" = "404" ]; then
        echo -e "   ${YELLOW}‚ö†Ô∏è  Respuesta 404 (normal si no hay index.html)${NC}"
    else
        echo -e "   ${YELLOW}‚ö†Ô∏è  Respuesta no est√°ndar: $BASIC_TEST${NC}"
    fi
    
    # An√°lisis autom√°tico de Valgrind si est√° disponible
    echo -e "\n${BLUE}üî¨ AN√ÅLISIS AUTOM√ÅTICO DE ERRORES (si disponible):${NC}"
    
    # Buscar archivos de Valgrind
    if [ -f "valgrind_detailed.log" ] || [ -f "server_eval.log" ]; then
        echo -e "${BLUE}üìã Archivo de an√°lisis encontrado - analizando errores...${NC}"
        
        # Extraer error count de cualquier log disponible
        ERROR_COUNT=0
        if [ -f "valgrind_detailed.log" ]; then
            ERROR_COUNT=$(grep "ERROR SUMMARY:" valgrind_detailed.log | tail -1 | sed -n 's/.*ERROR SUMMARY: \([0-9]*\) errors.*/\1/p' || echo "0")
        elif [ -f "server_eval.log" ]; then
            ERROR_COUNT=$(grep "Error count:" server_eval.log | tail -1 | sed -n 's/.*Error count: \([0-9]*\).*/\1/p' || echo "0")
        fi
        
        if [ "$ERROR_COUNT" -gt 0 ]; then
            echo -e "${RED}‚ö†Ô∏è  ERRORES DE MEMORIA DETECTADOS: $ERROR_COUNT${NC}"
            explain_error_count "$ERROR_COUNT"
            analyze_valgrind_errors
            
            echo -e "\n${YELLOW}üìö RECOMENDACIONES INMEDIATAS:${NC}"
            echo -e "   ${YELLOW}1. ANTES de continuar development, corregir errores cr√≠ticos${NC}"
            echo -e "   ${YELLOW}2. Ejecutar Valgrind con requests simples (no stress tests)${NC}"
            echo -e "   ${YELLOW}3. Usar herramientas: valgrind, gdb, AddressSanitizer${NC}"
            echo -e "   ${YELLOW}4. Revisar: initialization de variables, bounds checking${NC}"
            echo -e "   ${YELLOW}5. Priorizar: Invalid reads/writes > Uninitialized values${NC}"
        else
            echo -e "${GREEN}‚úÖ Sin errores de memoria detectados en an√°lisis${NC}"
        fi
    else
        echo -e "${BLUE}üí° No hay archivos de Valgrind disponibles para an√°lisis${NC}"
        echo -e "${BLUE}üîß Para an√°lisis detallado de memoria, ejecuta:${NC}"
        echo -e "${BLUE}   valgrind --leak-check=full --show-leak-kinds=all --track-origins=yes --log-file=valgrind_detailed.log ./webserv config/default.conf${NC}"
        echo -e "${BLUE}   Luego ejecuta stress tests para detectar problemas de memoria${NC}"
    fi
else
    echo -e "${RED}üíÄ ¬°SERVIDOR HA CA√çDO EN BATALLA!${NC}"
    echo -e "${RED}‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê${NC}"
    echo -e "${RED}   üí• El servidor muri√≥ durante las pruebas destructivas${NC}"
    echo -e "${RED}   üîç Esto indica vulnerabilidades serias en la implementaci√≥n${NC}"
    echo -e "${RED}   üõ†Ô∏è  Revisar: Memory leaks, buffer overflows, signal handling${NC}"
    echo -e "${RED}   üìö Consejo: Analizar logs y usar herramientas como valgrind${NC}"
    exit 1
fi

# Cleanup completo
echo -e "\n${BLUE}üßπ INICIANDO LIMPIEZA COMPLETA DEL CAMPO DE BATALLA...${NC}"
echo -e "${BLUE}üí° Eliminando todos los procesos de prueba y archivos temporales${NC}"
echo -e "${BLUE}üßΩ Activando limpieza final de zombies con requests CGI limpios${NC}"

# Primero, activar limpieza de zombies con requests CGI limpios
echo -e "\n${BLUE}üßΩ FASE 1: Activando limpieza final de zombies...${NC}"
echo -e "${BLUE}üí° Enviando 3 requests CGI limpios para activar waitpid() en webserv${NC}"
for i in {1..3}; do
    echo -e "   ${BLUE}‚Üí Request CGI $i/3...${NC}"
    curl -s http://localhost:9000/cgi-bin/script.py >/dev/null 2>&1
    sleep 0.5
done
echo -e "${GREEN}‚úÖ Limpieza de zombies activada${NC}"

# Luego limpiar procesos de prueba
echo -e "\n${BLUE}üóëÔ∏è  FASE 2: Eliminando procesos de prueba residuales...${NC}"
echo -e "${BLUE}üí° Matando procesos que puedan haber quedado de los stress tests${NC}"
echo -e "   ${BLUE}‚Üí Cerrando conexiones netcat...${NC}"
pkill -f "nc.*localhost:9000" 2>/dev/null || true
echo -e "   ${BLUE}‚Üí Cerrando conexiones curl...${NC}"
pkill -f "curl.*localhost:9000" 2>/dev/null || true
echo -e "   ${BLUE}‚Üí Cerrando procesos dd...${NC}"
pkill -f "dd.*if=/dev/zero" 2>/dev/null || true
echo -e "   ${BLUE}‚Üí Cerrando procesos CGI residuales...${NC}"
pkill -f "php-cgi" 2>/dev/null || true
pkill -f "python3.*script" 2>/dev/null || true
echo -e "${GREEN}‚úÖ Procesos de prueba eliminados${NC}"

# Limpiar archivos temporales de prueba
echo -e "\n${BLUE}üóÇÔ∏è  FASE 3: Limpiando archivos temporales creados durante tests...${NC}"
echo -e "${BLUE}üí° Eliminando archivos de prueba que se crearon durante los stress tests${NC}"
echo -e "   ${BLUE}‚Üí Eliminando scripts CGI temporales...${NC}"
rm -f /tmp/infinite_cgi.sh 2>/dev/null || true
echo -e "   ${BLUE}‚Üí Eliminando archivos de race conditions...${NC}"
rm -f www/Uploads/race_test.txt 2>/dev/null || true
echo -e "   ${BLUE}‚Üí Eliminando archivos bomb (resource exhaustion)...${NC}"
rm -f www/Uploads/bomb*.dat 2>/dev/null || true
echo -e "   ${BLUE}‚Üí Eliminando archivos big (memory stress)...${NC}"
rm -f www/Uploads/big*.dat 2>/dev/null || true
echo -e "   ${BLUE}‚Üí Eliminando archivos binarios de prueba...${NC}"
rm -f www/Uploads/binary.dat 2>/dev/null || true
echo -e "   ${BLUE}‚Üí Eliminando archivos temporales...${NC}"
rm -f www/Uploads/temp*.txt 2>/dev/null || true
echo -e "   ${BLUE}‚Üí Eliminando archivos de signal tests...${NC}"
rm -f www/Uploads/signal_test*.dat 2>/dev/null || true
echo -e "   ${BLUE}‚Üí Eliminando archivos de null bytes...${NC}"
rm -f www/Uploads/null.bin 2>/dev/null || true
echo -e "${GREEN}‚úÖ Archivos temporales eliminados${NC}"

echo -e "\n${GREEN}üéØ LIMPIEZA COMPLETA FINALIZADA${NC}"
echo -e "${GREEN}üí° El sistema ha sido restaurado al estado pre-testing${NC}"

echo -e "\n${GREEN}üéä ¬°STRESS TESTS DESTRUCTIVOS COMPLETADOS EXITOSAMENTE! üéä${NC}"
echo -e "${GREEN}üí™ Tu servidor webserv es un TANQUE BLINDADO de nivel militar! üõ°Ô∏è${NC}"
echo -e "${GREEN}üèÜ Ha sobrevivido a un bombardeo digital extremo que incluye:${NC}"
echo -e "${GREEN}   ‚öîÔ∏è  Requests HTTP malformados y datos basura${NC}"
echo -e "${GREEN}   üí• 500 conexiones TCP simult√°neas${NC}"
echo -e "${GREEN}   üß¨ Datos binarios aleatorios y caracteres especiales${NC}"
echo -e "${GREEN}   ÔøΩ 40+ procesos CGI concurrentes${NC}"
echo -e "${GREEN}   üíæ Memory stress con uploads de 10MB+${NC}"
echo -e "${GREEN}   üêå Ataques Slowloris y resource exhaustion${NC}"
echo -e "${GREEN}   üîê Intentos de path traversal y memory corruption${NC}"
echo -e "${GREEN}   üåä Protocol confusion y chunked encoding malformado${NC}"
echo -e "\n${GREEN}üìà ESTAD√çSTICAS FINALES DE SUPERVIVENCIA:${NC}"
echo -e "${GREEN}   ‚úÖ Tiempo total de testing: ~25-30 minutos${NC}"
echo -e "${GREEN}   ‚úÖ Categor√≠as de ataque resistidas: 16/16${NC}"
echo -e "${GREEN}   ‚úÖ Requests procesados: 1000+${NC}"
echo -e "${GREEN}   ‚úÖ Datos transferidos: 50MB+${NC}"
echo -e "${GREEN}   ‚úÖ Procesos fork(): 100+${NC}"

# Preguntar si quiere cerrar el servidor autom√°ticamente
echo -e "\n${YELLOW}ü§î GESTI√ìN DEL SERVIDOR:${NC}"
echo -e "${YELLOW}¬øQuieres cerrar el servidor webserv autom√°ticamente? [y/N]${NC}"
echo -e "${BLUE}üí° Si respondes 'y', el servidor se cerrar√° limpiamente${NC}"
echo -e "${BLUE}üí° Si respondes 'n' o no respondes, el servidor seguir√° ejecut√°ndose${NC}"
echo -e "${BLUE}‚è∞ Tienes 10 segundos para decidir...${NC}"
read -t 10 -r CLOSE_SERVER
if [[ $CLOSE_SERVER =~ ^[Yy]$ ]]; then
    echo -e "\n${BLUE}üî¥ CERRANDO SERVIDOR WEBSERV LIMPIAMENTE...${NC}"
    echo -e "${BLUE}üí° Enviando se√±al SIGTERM al proceso webserv (PID: $WEBSERV_PID)${NC}"
    kill $WEBSERV_PID 2>/dev/null || true
    sleep 1
    
    # Verificar que se cerr√≥ correctamente
    if ! kill -0 $WEBSERV_PID 2>/dev/null; then
        echo -e "${GREEN}‚úÖ Servidor cerrado correctamente${NC}"
        echo -e "${GREEN}üí° El proceso webserv ha terminado limpiamente${NC}"
    else
        echo -e "${YELLOW}‚ö†Ô∏è  Servidor a√∫n activo, enviando SIGKILL...${NC}"
        kill -9 $WEBSERV_PID 2>/dev/null || true
        sleep 1
        echo -e "${GREEN}‚úÖ Servidor terminado forzosamente${NC}"
    fi
    
    echo -e "\n${GREEN}üéØ TESTING COMPLETO Y SERVIDOR CERRADO${NC}"
    echo -e "${GREEN}üí° Tu webserv ha demostrado ser extremadamente robusto!${NC}"
else
    echo -e "\n${BLUE}‚ÑπÔ∏è  SERVIDOR WEBSERV SIGUE EJECUT√ÅNDOSE${NC}"
    echo -e "${BLUE}üñ•Ô∏è  PID: $WEBSERV_PID${NC}"
    echo -e "${BLUE}üåê URL: http://localhost:9000${NC}"
    echo -e "${BLUE}üí° Puedes cerrarlo manualmente desde la otra terminal o con:${NC}"
    echo -e "${BLUE}   ‚Üí kill $WEBSERV_PID${NC}"
    echo -e "${BLUE}   ‚Üí Ctrl+C en la terminal del servidor${NC}"
    echo -e "\n${GREEN}üéØ TESTING COMPLETO - ¬°FELICIDADES!${NC}"
    echo -e "${GREEN}üí° Tu servidor webserv ha pasado todas las pruebas con honores!${NC}"
fi

echo -e "\n${GREEN}üëë VEREDICTO FINAL: WEBSERV DE CALIDAD EMPRESARIAL üëë${NC}"
echo -e "${GREEN}üöÄ Listo para producci√≥n y alta concurrencia!${NC}"
